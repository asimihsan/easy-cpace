#!/usr/bin/env python3
import re
import sys
import textwrap
from pathlib import Path

# --- Configuration ---
HEADER_GUARD = "GENERATED_RFC_VECTORS_H"
OUTPUT_VAR_PREFIX = "RFC_B1"

# --- Helper Functions ---
def parse_hex_string(hex_str):
    """Cleans up and converts a potentially multi-line hex string to bytes."""
    return bytes.fromhex("".join(hex_str.split()))

def format_c_array(name, data):
    """Formats bytes into a C unsigned char array string."""
    if not data:
        return f"const unsigned char {name}[] = {{}};\nconst size_t {name}_LEN = 0;"

    hex_vals = [f"0x{b:02x}" for b in data]
    # Wrap lines nicely
    wrapper = textwrap.TextWrapper(width=100, subsequent_indent='    ', initial_indent='    ')
    wrapped_hex = wrapper.fill(", ".join(hex_vals))

    return f"const unsigned char {name}[] = {{\n{wrapped_hex}\n}};\nconst size_t {name}_LEN = sizeof({name});"

def find_vector(section_name, content):
    """Finds a hex vector block following a specific section name."""
    # Regex to find the section header and capture the following hex block
    # It handles multi-line hex values separated by whitespace.
    # It stops at the next blank line or section header.
    pattern = re.compile(
        rf"^\s*{re.escape(section_name)}:.*?^\s*\(length: \d+ bytes\)\s*([\da-fA-F\s]+?)(?=\n\s*\n|\n\s*#|\n\s*\w|\Z)",
        re.MULTILINE | re.DOTALL | re.IGNORECASE
    )
    match = pattern.search(content)
    if match:
        return parse_hex_string(match.group(1).strip())
    else:
        print(f"Error: Could not find vector for '{section_name}'", file=sys.stderr)
        return None

def find_input_hex(input_name, content):
    """Finds a hex value assigned to an input variable."""
    pattern = re.compile(rf"^\s*{re.escape(input_name)}\s*=\s*([\da-fA-F]+)", re.MULTILINE | re.IGNORECASE)
    match = pattern.search(content)
    if match:
        return parse_hex_string(match.group(1).strip())
    else:
        print(f"Error: Could not find input hex for '{input_name}'", file=sys.stderr)
        return None

# --- Main Script Logic ---
def main(input_path, output_path):
    try:
        content = Path(input_path).read_text()
    except FileNotFoundError:
        print(f"Error: Input file not found at '{input_path}'", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading input file '{input_path}': {e}", file=sys.stderr)
        sys.exit(1)

    vectors = {}
    errors = False

    # Parse Inputs
    vectors['PRS'] = find_input_hex('PRS_HEX', content)
    vectors['CI'] = find_input_hex('CI_HEX', content)
    vectors['sid'] = find_input_hex('sid', content)
    vectors['ADa'] = find_input_hex('ADa', content)
    vectors['ADb'] = find_input_hex('ADb', content)
    vectors['s'] = find_input_hex('s', content)
    vectors['u0'] = find_input_hex('u0', content)
    vectors['u1'] = find_input_hex('u1', content)
    vectors['u2'] = find_input_hex('u2', content)
    vectors['u3'] = find_input_hex('u3', content)
    vectors['u4'] = find_input_hex('u4', content)
    vectors['u5'] = find_input_hex('u5', content)
    vectors['u7'] = find_input_hex('u7', content)


    # Parse Outputs
    vectors['generator_string'] = find_vector('generator_string', content)
    vectors['generator_hash'] = find_vector('hash generator string', content)
    vectors['g'] = find_vector('generator g', content)
    vectors['Ya'] = find_vector('Ya = X25519(xa, g)', content)
    vectors['Yb'] = find_vector('Yb = X25519(xb, g)', content)
    vectors['K'] = find_vector('K = X25519(xa, Yb)', content)
    vectors['ISK_Input_String'] = find_vector('ISK Input String', content)
    vectors['ISK_IR'] = find_vector('ISK_IR = H(ISK Input String)', content)


    # Check for parsing errors
    for name, data in vectors.items():
        if data is None:
            print(f"Failed to parse vector: {name}", file=sys.stderr)
            errors = True

    if errors:
        sys.exit(1)

    # Generate Header File Content
    header_content = f"""\
// Automatically generated by {Path(__file__).name} from {Path(input_path).name}
// DO NOT EDIT MANUALLY!

#ifndef {HEADER_GUARD}
#define {HEADER_GUARD}

#include <stddef.h> // For size_t
#include <stdint.h> // For uint8_t

// --- RFC Appendix B.1 Test Vectors ---

"""

    for name, data in sorted(vectors.items()):
        c_name = f"{OUTPUT_VAR_PREFIX}_{name.upper()}"
        header_content += format_c_array(c_name, data) + "\n\n"

    header_content += f"#endif // {HEADER_GUARD}\n"

    # Write Header File
    try:
        Path(output_path).write_text(header_content)
        print(f"Successfully generated '{output_path}'")
    except Exception as e:
        print(f"Error writing output file '{output_path}': {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <input_rfc_txt_file> <output_c_header_file>", file=sys.stderr)
        sys.exit(1)
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    main(input_file, output_file)
